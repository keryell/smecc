#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

/** Initialize a 2D array with some progressive values

    @param width is the size of the array in the second dimension

    @param height is the size of the array in the first dimension

    @param[out] array is the array to initialize

    Note that we could also use this [out] Doxygen information to avoid
    specifying it again in the #pragma...
*/
void init_image(int width, int height, int array[height][width]) {
  // Can be executed in parallel
#pragma omp parallel for
  for(int i = 0; i < height; i++)
    for(int j = 0; j < width; j++)
      // Initialize with stripes:
      array[i][j] = (i + 3*j) >> ((i - j) & 7);
}


/** Write the content of an array to Portable Gray Map image format (PGM)

    @param[in] filename is the name of the file to write into the image

    @param n is the size of the array in the first dimension

    @param m is the size of the array in the second dimension

    @param[in] array is the array to use as image content. Note we could
    infer the [in] information and communication directions directly from
    "const" qualifier
*/
void write_pgm_image(const char filename[], int width, int height,
		     const unsigned char array[height][width]) {
  FILE * fp;

  char * comments = "# This is an image generated by the " __FILE__
    " program.\n"
    "# SMECY ARTEMIS European project.\n";
  // Open the image file for writing:
  if ((fp = fopen(filename, "w")) == NULL) {
    perror("Error opening file");
    exit(EXIT_FAILURE);
  }

  /* Write the PGM header which begins with, in ASCII decimal, the
     width, the height and the maximum gray value (255 here): */
  fprintf(fp,"P5\n%d %d\n%s%d\n", width, height, comments, UCHAR_MAX);

  for(int i = 0; i < height; i++)
    for(int j = 0; j < width; j++)
      // Write a pixel value:
      fputc(array[i][j], fp);

  // Close the file:
  fclose(fp);
}


/** Normalize an array of integer values into an array of unsigned char

    This is typically used to generate a gray image from arbitrary data.

 */
void normalize_to_char(int width, int height, int array[height][width],
		       unsigned char output[height][width]) {
  /* First find the minimum and maximum values of array for
     later normalization: */
  // Initialize the minimum value to the biggest integer:
  int minimum = INT_MAX;
  // Initialize the maximum value to the smallest integer:
  int maximum = INT_MIN;
  // min & max from next OpenMP 3.1 not yet implemented in gcc 4.6 :-(
  //#pragma omp parallel for reduction(min:minimum) reduction(max:maximum)
  for(int i = 0; i < height; i++)
    for(int j = 0; j < width; j++) {
      int v = array[i][j];
      if (v < minimum) minimum = v;
      else if (v > maximum) maximum = v;
    }

  // Now do the normalization
  float f = UCHAR_MAX/(float)(maximum - minimum);
#pragma omp parallel for
  for(int i = 0; i < height; i++)
    for(int j = 0; j < width; j++)
      output[i][j] = (array[i][j] - minimum)*f;
}


/* Apply a vertical symmetry to a subsquare in an image

*/
void square_symmetry(int width, int height, int image[height][width],
		     int square_size, int x_offset, int y_offset) {
  // Can be executed in parallel
#pragma omp parallel for
  for(int i = 0; i < square_size/2; i++)
    for(int j = 0; j < square_size; j++) {
      int tmp = image[y_offset + i][x_offset + j];
      image[y_offset + i][x_offset + j] =
	image[y_offset + square_size - i][x_offset + j];
      image[y_offset + square_size - i][x_offset + j] = tmp;
    }
}


