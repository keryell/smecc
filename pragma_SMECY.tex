\documentclass[a4paper]{article}
\usepackage[latin9]{inputenc}
\usepackage{alltt,url}
\usepackage{listings}

\lstset{language=C, numbers=left, numberfirstline=false, stepnumber=5,
  basicstyle=\small, keywordstyle=\bf}

% For various symbols:
\let\OldRightarrow=\Rightarrow
\RequirePackage{marvosym}
\let\MarvosymRightarrow=\Rightarrow
\let\Rightarrow=\OldRightarrow
\RequirePackage{wasysym}
% Deal with conflicts between ifsym and marvosym by renaming conflicting
% symbols:
\let\MarvosymLightning=\Lightning
\let\Lightning=\UnTrucIndefini
\let\MarvosymLetter=\Letter
\let\Letter=\UnTrucIndefini
\let\MarvosymSun=\Sun
\let\Sun=\UnTrucIndefini
\RequirePackage[weather,misc,alpine,clock]{ifsym}

\begin{document}

\title{SMECY C (or SME-C? \smiley) \\
  ---\\
  C99 with pragma and API for parallel execution, processor mapping and
  communication generation}

\author{\texttt{Remi.Barrere@thalesgroup.com} \and
  \texttt{Ronan.Keryell@hpc-project.com}}

\maketitle

\section{Introduction}
\label{sec:introduction}

In the SMECY project we want to use C source code as a portable
intermediate representation (IR) between tools from high-level tools down
to lower-level tools because of its good trade-off between expressiveness
and readability, without compromising portability.

The targets envisioned in SMECY are heterogeneous multicore systems with
shared memory or not, with various hardware accelerator, such as ASIC,
ASIP, FPGA, GPU, specialized vector processors, partially reconfigurable
accelerators...

Unfortunately, since it is undecidable to get high-level properties from
such programs, we use decorations to help tools to understand program
behaviour and generate codes for some hardware targets. We try to keep
clear decorations, easy to understand, so that SMECY C can also used as a
programming language.

A SMECY program contains various functions that may be executed on various
processors, accelerators, GPU... that may consume and produce data from
different physical memory spaces.

Since we want to express also performance on given platforms, we keep the
opportunity to have platform-specific pragma and API or specialized
intrinsic types and functions, for example to express use of special
hardware accelerator functions or operations.

The hardware specific pragma and intrinsics are to be defined between
software and hardware partners involved in various use cases. But it may
not possible to address all the programming models and platforms
envisioned in the project.


\subsection{SMECY-C programming model}
\label{sec:programming-models}

The programming model is based on C processes, with a virtual shared
memory and threads \emph{à la} OpenMP. Since we may have quite
asynchronous processes in a real application description or at the
back-end level in the execution model, we can cope indeed with different C
processes communicating with an API.

We add mapping information stating on which hardware part a function is to
be placed and run.

The programming model exposed in the following is based on an OpenMP SMP
model because of its (rather) simple readability, elegance, old background
and wide acceptance. We make the hypothesis that a SMECY program is a
correct OpenMP program that can be executed in sequential with a C
OpenMP-free compiler (just by ignoring OpenMP \verb|#pragma|) and in
parallel on a SMP target (such an $x$86 machine) by using an OpenMP
compiler \emph{with the same semantics}. Since we use C (by opposition to
a DSL) as an internal representation, we choose this behaviour to stick to
standard behaviour as much as possible. This is known as the sequential
equivalence. Since we can cope different results for performance reasons
from executing in parallel non associative floating point operations, we
deal with only \emph{weak} sequential equivalence instead of
\emph{strong} sequential equivalence.

Of course, this model is incompatible with a real hardware target
envisioned in SMECY, so we need to add hints in the code explaining memory
dependencies at the function call levels. Since it is quite difficult to
describe general dependencies, we approximate memory dependencies with
rectangles (and more generally hyperparallelepipede in any dimension) that
can be read, written or both. We think these abstractions are good
trade-offs between expressiveness (and what a programmer can endure...)
and hardware capabilities. Even if there is some similitude with HPF
(High Performance Fortran) we do not deal with strides\footnote{Indeed, by
  using some higher dimensional arrays than the arrays used in the
  application, you can express them... So may be we can express them in
  the syntax?}.

With this information the tools can guess the communication to generate
between the different functions and memory spaces to emulate the global
OpenMP memory semantics.

The neat side effect is that we have the same global program executed on
all the platforms (sequential, real OpenMP and SMECY) with the same
semantics and we can see the sequential version as a functional simulator
of the SMECY application and the real OpenMP version as a parallelized
quicker version of this simulator.

It is also easy to debug the application, but also all the SMECY tools
used or developed in the project.

To be able to address real hardware from the C level with special needs:
\begin{itemize}
\item to specify hardware register names;
\item define input/output routines specifically but in portable way;
\item define fixed point computations;
\item specific data size;
\item accumulator register (DSP...);
\item different memory spaces that can be chosen specifically to optimize
  storage and speed (DSP, hardware accelerators with scratch pad
  memory...);
\item saturated arithmetic.
\end{itemize}
For all these we rely on the TR 18037 Embedded C standard, supported for
example by ACE tools.

To describe different processes communicating together in an asynchronous
way, we do not have anymore a sequential equivalence and then do not use
pragma to express this. So we use a simple communication, synchronization
and threading API. Since we target embedded systems with a light efficient
implementation, we can rely on such standard API as the ones of the
MultiCore Association: MCAPI (communication), MRAPI (synchronization) and
MTAPI (threading).

As modern programs need a clear documentation, such as with Doxygen
marking style providing meta information on different elements of the
program, we can use this (hopefully correct) information to help the
compiling process itself.

Since tools are to be oriented for a specific target, taking into account
various hardware and compilation parameters that are to be kept
orthogonally to application sources, those parameters are kept aside in
some description files that flow between tools. These files may be
represented with an XML syntax (using a SMECY naming space) or by even
simpler format (JASON, YAML...).


\subsection{Reference documents}
\label{sec:reference-documents}

Besides the SMECY documentation, the reader should be knowledgeable of
some work of the ISO/IEC JTC1/SC22/WG14 committee on the C language
standard:
\begin{itemize}
\item ISO/IEC 9899 - Programming languages - C (Technical Corrigendum 3
  Cor. 3:2007(E))
  \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf}
\item TR 18037: Embedded C
  \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1169.pdf}
\item Future C1X standard
  \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf}
\end{itemize}
and other standards such as
\begin{itemize}
\item MCA (MultiCore Association) API: MCAPI, MRAPI \& MTAPI,
  \url{www.multicore-association.org}
\item HPF (High Performance Fortran)
  \url{http://hpff.rice.edu/versions/hpf2}
\item ISO/IEC TR 24717:2009, Information technology -- Programming
  languages, their environments and system software interfaces --
  Collection classes for programming language COBOL 20$xx$
  \url{http://www.cobolstandard.info/j4/files/std.zip}
\end{itemize}


\section{Intermediate representation use cases}
\label{sec:interm-repr-use}

\subsection{Direct programming}
\label{sec:direct-programming}

A programmer can program her application directly in SMECY C with OpenMP
and SMECY-specific pragma and API to target a SMECY platform.

It can be at rather high-level, by using only high-level pragma, or rather
at a lower level, by using different communicating processes with the API
and even specialized API and pragma for specific hardware.

A process written in C code with pragma and API can express a global host
controlling process of an application or a local program in a specialized
processor. And we may have many of such processes to express different
producer and consumer Kahn processes interacting through a NoC in an
asynchronous way.


\subsection{System high-level synthesis}
\label{sec:high-level-synthesis}

A compiler can take a sequential plain C or Matlab or another language
code, analyze and parallelize the code by adding automatically parallel
and mapping pragma. This can be seen as a high-level synthesis at system
level.

A tool such as Par4All can do these kinds of transformation.


\subsection{Hardware high-level synthesis}
\label{sec:hardware-high-level}

A compiler can take a program with SMECY pragma and compile any call with
a mapping of a given kind into some hardware configuration or program to
be executed instead of the function and an API call to use this
hardware part from the host program.

Since the pragma are designed to be concretely compilable, such a tool
should be easy to do with a simple compilation framework, such as ROSE
Compiler.

The SMECY API and intrinsics are chosen to be mapped quite
straightforwardly to real hardware functions by the back-end.


\section{Exemples}
\label{sec:exemples}

\subsection{Program with contiguous memory transfers}
\label{sec:progr-with-cont}

During C memory transfer, if we work on arrays with the last dimension
taken as a whole, the memory is contiguous and the programs often work
even there are some aliasing such as using a 2D array zone as a linearized
1D vector.

The following program exposes this kind of code where some work sharing is
done by contiguous memory blocks.

\lstinputlisting{examples/pragma_example.c}


\subsection{Program with non-contiguous memory transfers}
\label{sec:program-with-non}

In the following example, we apply different computations on square pieces
of the image, that do not have contiguous representation in memory. That
is why we need to express restrictions on the use of the whole array.

\lstinputlisting{examples/2D_example.c}


\subsection{Pipelined example}
\label{sec:pipelined-example}

\emph{TODO}

\subsection{Remapping example}
\label{sec:remapping-example}

Some information can be in a given layout but needed in another layout to
be used by a specific hardware accelerator.

\lstinputlisting{examples/remapping_example.c}


\section{SMECY embedded C language}
\label{sec:embedded-c}

We take as input C99 (ISO/IEC 9899:2007) language with extension for
embedded systems (TR 18037).

Refer to these document for more information.


\section{Description of the SMECY directives}
\label{sec:description}

The generic format of SMECY code decorations are language dependent,
because if here we describe a SMECY IR implementation based on C, it is
indeed more general.

\begin{itemize}
\item In C/C++:
\begin{alltt}
#pragma smecy \emph{clause[[,]clause]... newline}
\end{alltt}
  We can use \verb|\| at the end of line for continuation information.
\item In Fortran:
\begin{alltt}
!$smecy \emph{clause[[,]clause]... newline}
\end{alltt}
  Use \verb|&| at the end of line for continuation information.
\item In other languages: use \verb|#pragma| equivalent, if not available,
  use comments \emph{à la} Fortran. For example in Python:
\begin{alltt}
#$smecy \emph{clause[[,]clause]... newline}
\end{alltt}
  Use also \verb|&| at the end of line for continuation information
\end{itemize}

In implementations that support a preprocessor, the \verb|_SMECY| macro
name is defined to have the decimal value \emph{yyyymm} where \emph{yyyy}
and \emph{mm} are the year and month designations of the version of the
SMECY API that the implementation supports.  If this macro is the subject
of a \verb|#define| or a \verb|#undef| preprocessing directive, the
behavior is unspecified.



\subsection{OpenMP support}
\label{sec:openmp-support}

SMECY is based on OpenMP. It is not clear yet what level of OpenMP is
supported. Since a SMECY platform is made at least form a (SMP) control
processor, any OpenMP compliant program can run on it anyway.

But the SMECY tools can use more or less information from available OpenMP
decorations available in the code.


\subsection{Mapping on hardware}
\label{sec:mapping-hardware}

The mapping of a function call on a specific piece of hardware can be
specified with
\begin{alltt}
#pragma smecy map(\emph{hardware[}, \emph{unit]})
some_function_call(...);
\end{alltt}

\begin{itemize}
\item \texttt{\emph{hardware}} is a symbol representing a hardware
  component of a given target such as \texttt{CPU}, \texttt{GPP},
  \texttt{GPU}, \texttt{PE}... They are target specific.
\item \texttt{\emph{unit}} is an optional instance number for a specific
  hardware part. This is typically an integer starting a 0. This hardware
  number can be an expression of the environment to be able to have a loop
  managing different accelerators.
\end{itemize}

We can add an \texttt{if(\emph{scalar-expression})} to predicate hardware
launching according some run-time expression to choose between hardware or
local software execution, as in OpenMP with the same syntax. The idea is
to be able to do a software execution if the data to process is too small
compared to the latency of an hardware accelerator.

Recursion is not supported on hardware-mapped functions. If there are
functions called from hardware-mapped functions, they will be
automatically inlined (so no recursion allowed in them either). If a
function is mapped to a more programmable hardware (GPP), recursions in
these called functions should be allowed.


\subsection{Producer/consumer information}
\label{sec:prod-inform}

To generate hardware communications where there is only a function call,
the compiler need to figure out what is the memory zone used to execute
the function and then what memory zone in written by the function
\emph{and} that will be used later in the program\footnote{If a function
  produces something not used later, it is useless to get it back.}. From
these information, copy-in and copy-out operations can be generates.

\subsubsection{Function arguments}
\label{sec:function-arguments}


\begin{alltt}
#pragma smecy arg(\emph{arg_id}, \emph{arg_clause[, arg_clause]...})
some_function_call(...);
\end{alltt}


\begin{description}
\item[Direction directive] defines how the data flows between the caller
  and the function:
  \begin{itemize}
  \item \texttt{in} the argument is used by the function;
  \item \texttt{out} the argument is used by the function;
  \item \texttt{inout} the argument is used and produced by the function;
  \item \texttt{unused} the argument is not used and produced by the
    function.
  \end{itemize}

\item[Argument layout] specifies how the argument is used in the
  function.
  \begin{itemize}
  \item An optional \texttt{\emph{array\_size\_descriptor}} such as
    \verb|[n][m]| expressing that the data is used from the callee point
    of view as such an array starting at the address given in
    parameter. If not specified, all the caller argument is used;
  \item An optional \texttt{/\emph{array\_range\_descriptor}}restriction
    such as \verb|/[n:m][2][3:7]| expressing that the data is used from the
    callee point of view as an array with only this element ranges
    used. If not specified, all the array is used according to its size
    specified or not. If only some ranges are lacking, all the matching
    dimension is used. For example \verb|/[4][]| matches the column 4 of
    an array.
  \end{itemize}
  The more precise this description is and the less data transfers occur.
\end{description}


\subsubsection{Global variables}
\label{sec:global-variables}


Right now we do not deal with sharing information through global
variables, because it is more difficult to track. Only function parameters
are used to exchange information.

But we can imagine to map global variables with this clause:
\begin{alltt}
#pragma smecy global_var(var, \emph{arg_clause[, arg_clause]...})
\end{alltt}


\subsection{Remapping specification}
\label{sec:remapp-spec}

\emph{TO FINISH}

Since we always want a sequential equivalence, that means that the
sequential code representing the computation on an accelerator really
consume The easy

HPF



\subsection{Hardware specific pragma}
\label{sec:hardw-spec-pragma}

\emph{To be defined in collaboration with the various hardware suppliers
  of the project (P2012, EdkDSP...).}


\section{SMECY high-level API}
\label{sec:smecy-api}

\subsection{OpenMP}
\label{sec:openmp}

Since we support OpenMP pragma, we also support OpenMP API that allows for
example:
\begin{itemize}
\item getting/setting the number of threads;
\item getting the number of available processors on the current domain;
\item manipulating locks.
\end{itemize}


\subsection{MultiCore Association API}
\label{sec:mult-assoc-api}

We rely on the MCAPI, MTAPI and MRAPI for low memory footprint
light-weight communications, threading and synchronization. Refer to their
documentations for more information.

There is a reference implementation based on Linux \emph{pthreads} that
can be used as an example to port to the various available hardware.

This can be used to express communicating process, asynchronous
communications, synchronization, etc.


\subsection{NPL API}
\label{sec:npl-api}

NPL is the API defined to program ST P2012 in a native way. Since it is
rather at the same level of MCAPI/MRAPI/MTAPI, it should be easy to
implement one above the other. Since the MCA APIs are standard, we thing
that it is commercially interesting to provide a MCA APIs over NPL or
other to widen P2012 usage.

\emph{Define here NPL}


\subsection{EdkDSP API}
\label{sec:edkdsp-api}

\emph{Define here what is useful in the project.}


\subsection{OpenCL}
\label{sec:opencl}

Since ST P2012 can be programmed in OpenCL which is also a programming
API, a C process can use OpenCL orthogonally with other API. A kernel
launching is done by defining the kernel source, the memory zone to use
and to transfer and the different parameters of the kernel.

Refer to OpenCL documentation for more information.


\section{Compilation}
\label{sec:compilation}

\subsection{OpenMP support}
\label{sec:openmp-support-1}

From the programmer point of view it may be equivalent to have
\begin{itemize}
\item an OpenMP compiler generating SMECY API code such as the parallelism
  between SMECY target accelerators is run by OpenMP threads dealing each
  one with an hardware resource sequentially in a synchronous way;
\item or a SMECY compiler understanding the OpenMP syntax and generating
  directly some parallel execution of SMECY accelerators in an
  asynchronous way.
\end{itemize}


\subsection{Information available}
\label{sec:inform-avail}

\subsubsection{Doxygen qualifier}
\label{sec:doxygen-qualifier}

In the Doxygen documentation mark-up language used in comments to detail
various entities of a program, there are information such as \texttt{in},
\texttt{out} or \texttt{inout} qualifier on function parameters that can
be used to generate the right communication with some hardware
accelerators.


\subsubsection{C qualifier}
\label{sec:c-qualifier}

Qualifiers such as \texttt{const} attribute qualifier, address space
names, register names, accumulator, saturation, etc. are used to generate
the right target function or instruction.


\subsubsection{Pragma}
\label{sec:pragma}

Of course the pragma information is heavily used in the compilation
process

For example to generate correct communication, the mapping information is
used, and from the used/defined information plus optional remapping
information, a real communication with an API is used.

\begin{lstlisting}
void
invert_vector(int line_size,
	      int input_line[line_size],
	      int output_line[line_size]) {
  for(int i = 0; i < line_size; i++)
    output_line[i] = 500 - input_line[i];
}
  [...]
  int image[HEIGHT][WIDTH];
  [...]
#pragma smecy map(PE, proc & 7)			\
              arg(2, in, [1][LINE_SIZE])	\
              arg(3, out, [1][LINE_SIZE])
    // Invert an horizontal line:
    invert_vector(LINE_SIZE,
		  &image[HEIGHT - 20 - proc][WIDTH/2 + 2*proc],
		  &image[HEIGHT - 20 - proc][WIDTH/2 + 2*proc]);
\end{lstlisting}
can be compiled into
\begin{lstlisting}
  int image[HEIGHT][WIDTH];
  /* First prepare the PE #(proc & 7) hardware to execute invert_vector.
     That may be used to load some program or microcode, reconfigure a
     FPGA, load/compile an OpenCL kernel... */
  SMECY_set(PE, proc & 7, invert_vector);
  /* Send the WIDTH integer as arg 1 on invert_vector hardware function on
     PE #(proc & 7): */
  SMECY_send_arg(PE, proc & 7, invert_vector, 1, int, LINE_SIZE);
  /* Send a vector of int of size LINE_SIZE as arg 2 on invert_vector
     hardware function on PE #(proc & 7): */
  SMECY_send_arg_vector(PE, proc & 7, invert_vector, 2, int,
                        &image[HEIGHT - 20 - proc][WIDTH/2 + 2*proc], LINE_SIZE);
  // Launch the hardware function or remote program:
  SMECY_launch(PE, 0, invert_vector);
  /* Get a vector of int of size LINE_SIZE as arg 3 on invert_vector
     hardware function on PE #(proc & 7): */
  SMECY_get_arg_vector(PE, proc & 7, invert_vector, 3, &image[HEIGHT - 20 - proc]
                                                             [WIDTH/2 + 2*proc],
                       LINE_SIZE);
\end{lstlisting}
with low level macros described in \S~\ref{sec:low-level-hardware}.

\lstinline|invert_vector()| is either an already implemented function in a
hardware library, or it is compiled by a target specific compiler with
some callable interface.

For more complex calls needing remapping, such as:
\begin{lstlisting}
    int input_line[LINE_SIZE];
    int output_line[LINE_SIZE];
    /* We need to remap data in the good shape. The compiler should use
       the remapping information to generate DMA transfer for example and
       remove input_line array */
    SMECY_remap_int2D_to_int1D(HEIGHT, WIDTH, HEIGHT/3, 30 + 20*proc,
			       LINE_SIZE, 1, image,
			       LINE_SIZE, input_line);
    // Each iteration is on a different PE in parallel:
#pragma smecy map(PE, proc) arg(2, in, [LINE_SIZE]) arg(3, out, [LINE_SIZE])
    invert_vector(LINE_SIZE, input_line, output_line);
    SMECY_remap_int1D_to_int2D(LINE_SIZE, output_line,
			       HEIGHT, WIDTH, HEIGHT/3, 30 + 20*proc,
			       LINE_SIZE, 1, image);
\end{lstlisting}
is compiled by using other hardware interfaces involving more complex DMA:
\begin{lstlisting}
  // May not be useful if this function is already set:
  SMECY_set(PE, proc & 7, invert_vector);
  /* Send the WIDTH integer as arg 1 on invert_vector hardware function on
     PE #(proc & 7): */
  SMECY_send_arg(PE, proc & 7, invert_vector, 1, int, LINE_SIZE);
  /* Send a vector of int of size LINE_SIZE as arg 2 on invert_vector
     hardware function on PE #(proc & 7) but read as a part of a 2D array: */
  smecy_send_arg_int_DMA_2D_PE_0_invert_vector(3, &image[HEIGHT - 20 - proc]
                                                        [WIDTH/2 + 2*proc],
                                               HEIGHT, WIDTH, HEIGHT/3, 30 + 20*proc,
			                                   LINE_SIZE, 1);
  SMECY_send_arg_DMA_2D_to_1D(PE, proc & 7, invert_vector, 2, int,
                              &image[HEIGHT - 20 - proc][WIDTH/2 + 2*proc],
                              HEIGHT, WIDTH, HEIGHT/3, 30 + 20*proc,
			                  LINE_SIZE, 1);
  // Launch the hardware function or remote program:
  SMECY_launch(PE, 0, invert_vector);
  SMECY_get_arg_DMA_1D_to_2D(PE, proc & 7, invert_vector, 3, int,
                             &image[HEIGHT - 20 - proc][WIDTH/2 + 2*proc],
                             HEIGHT, WIDTH, HEIGHT/3, 30 + 20*proc,
			                 LINE_SIZE, 1);
\end{lstlisting}


\subsection{Geometric inference}
\label{sec:geometric-inference}

In the OpenMP SMP model, there is a global memory (well, with a weak
coherence model) that may not exist in the execution model of a given
target. For example, even if 2 hardware accelerators exchange information
through memory according to the high-level programming model, in the real
world we may have 2 processors communicating through message passing with
MCAPI on a NoC or 2 hardware accelerators connected through a pipeline.

To solve this issue, we use the OpenMP global memory like a scoreboard
memory that is used to symbolically relate all the data flows and
generates various communication schemes.

Since the memory dependencies are expresses by hyperparallelepipedes, we
can do some intersection analysis to compute if a communication is needed
or not between 2 devices of the target.


\section{SMECY low level hardware API}
\label{sec:low-level-hardware}

To call real hardware accelerators, few C macros are needed to interface a
program running on some processor to a function running on another
processor or in some hardware accelerator.

Since the implementation may depend also on the processor calling the
macros (not the same IO bus will be used from an $x$86 or a DSP to call
the same operator), a global preprocessing symbol must be defined by the
compiler before using these macros, such as
\begin{lstlisting}
#define SMECY_LOCAL_PROC x86
\end{lstlisting}
or
\begin{lstlisting}
#define SMECY_LOCAL_PROC DSP
\end{lstlisting}

Few macros are necessary:
\begin{lstlisting}
/* Prepare a processing element to execute a function

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to load on the processor element
*/
#define SMECY_set(pe, instance, func) ...

/* Send a scalar argument to a function on a processing element

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to load on the processor element
   @param[in] arg is the argument instance to set
   @param type is the type of the scalar argument to send
   @param[in] val is the value of the argument to send
*/
#define SMECY_send_arg(pe, instance, func, arg, type, val) ...

/* Send a vector argument to a function on a processing element

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to load on the processor element
   @param[in] arg is the argument instance to set
   @param type is the type of the vector element to send
   @param[in] addr is the starting address of the vector to read from
              caller memory
   @param[in] size is the length of the vector
*/
#define SMECY_send_arg_vector(pe, instance, func, arg, type, addr, size) ...

/* Launch the hardware function or remote program using previously loaded
   arguments

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to load on the processor element

   A kernel can be launched several times without having to set/reset its function.
*/
#define SMECY_launch(pe, instance, func) ...

/* Get the return value of a function on a processing element

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to load on the processor element
   @param type is the type of the scalar argument to send
   @return the value computed by the function
*/
#define SMECY_get_return(pe, instance, func, type) ...

/* Get a vector value computed by a function on a processing element

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to load on the processor element
   @param[in] arg is the argument instance to retrieve
   @param type is the type of the vector element
   @param[out] addr is the starting address of the vector to write in
               caller memory
   @param[in] size is the length of the vector
*/
#define SMECY_get_arg_vector(pe, instance, func, arg, type, addr, size) ...

/* Reset a processing element to execute a function

   @param pe is the symbol of a processing element, such as GPP, DSP, PE...
   @param[in] instance is the instance number of the processor element to use
   @param func is the function to unload from the processor element

   This is used for example to remove consuming resources to decrease
   power. Giving here the function name may be useful for weird case to
   avoid having short-circuit between CLB in a FPGA during unconfiguring stuff
*/
#define SMECY_reset(pe, instance, func) ...
\end{lstlisting}
There is also a macro for an asynchronous call and to wait for completion.
\end{document}


%%% mode: latex
%%% TeX-master: t
%%% TeX-auto-untabify: t
%%% Tex-PDF-mode: t
%%% ispell-local-dictionary: "american"
%%% End:
% vim: spell spelllang=en
